---
layout: post
title:  "PLP: Lecture 13"
date:   2017-02-03
category: lecture-notes
keywords:
- 
---

<script type="text/javascript" async
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } },
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
});
</script>

---

## Synthesized and Inherited Attributes

Synthesized attributes have their values only calculated in productions where the associated symbol appears on the left hand side. All dependencies point from the child to parent in the parse tree. In some cases, the scanner can compute  

An inherited attribute is one that is not synthesized. Imformation may flow to a node from the parent or siblings. 

In compilers, symbol table information is often pased using inherited attributes. *Look at example in Scott (4.3?) where he uses an inherited attribute grammar in an LL(1) grammar for expressions to obtain left associativity.*

## Attribute flow

AGs are **declarative**- define set of valid trees, but don't specify how to build or decorate them.

AGs can be well-defined; rules determine a unique set of values for every possible parse tree. Also can be non-circular; never yield a parse tree with cycles in the attribute flow graph. They can also be both circular and well-defined. 

## Obvious scheme

Repeated passes over the tree, computing any attribute whose arguments are defined. Terminates when values no longer change.

If tree is non-cyclic, use a dynamic scheme that tailors the evaluation order to the structure of the given tree. 

## In compilers

Fastest translation schemes are static on a restricted set of AGs.
Anything interleaved with parsing in a recursive descent parser must be specifiable with an L-attributed grammar. 

## S-attributed AG

All attributes are synthesized. Can be computed by single bottom-up traversal of the syntax tree. This can be interleaved with parsing. 

## L-attributed AG

Can be computed with a single left-to-right depth first traversal of the parse tree. Can be computed on-the-fly during an LL(1) parse.

